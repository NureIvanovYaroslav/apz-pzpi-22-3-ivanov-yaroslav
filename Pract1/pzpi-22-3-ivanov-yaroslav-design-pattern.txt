Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії




ЗВІТ
з практичного заняття №1
з дисципліни  «Архітектура програмного забезпечення»
на тему: «Патерни проєктування»




Виконав
ст. гр. ПЗПІ-22-3
Іванов Ярослав В’ячеславович

Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович







Харків 2025
ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	10.04.2025	0.1	Зроблено структуру звіту
2	10.04.2025	0.1	Описано розділ «Завдання»
3	22.04.2025	0.1	Описано розділ «Опис виконаної роботи»
4	30.04.2025	0.1	Наведено прикладу коду. Заповнено додаток В.
5	02.05.2025	0.1	Наведено слайди презентації. Заповнено додаток Б.
6	04.05.2025	0.1	Наведено посилання на відеозапис доповіді. Заповнено додаток А.

1 ЗАВДАННЯ

     Дослідити патерн проектування «Стратегія», його призначення, структурні особливості, варіанти застосування, переваги та недоліки. У межах виконання завдання буде проведено аналіз патерну шляхом його практичної реалізації на мові програмування TypeScript, розглянуто різні підходи до його використання та оцінено ефективність у різних сценаріях.

2 ОПИС ВИКОНАНОЇ РОБОТИ

     Доповідь була оформлена та презентована у відеозаписі з використанням відповідних слайдів. Відео доступне за посиланням у додатку А, а матеріали презентації включені до додатку Б.
     У процесі розробки сучасних програмних систем надзвичайно важливим є досягнення гнучкості, масштабованості та повторного використання коду. Ці характеристики прямо впливають на вартість розробки, швидкість внесення змін, зручність супроводу та загальну надійність програмного продукту. Для досягнення таких показників у професійній розробці активно використовуються шаблони проєктування, або патерни.
     У межах виконаної роботи було обрано та досліджено поведінковий патерн проєктування «Стратегія». Метою його дослідження стало глибоке розуміння його призначення, структури, механізму реалізації, переваг, недоліків та сфер практичного застосування.
     Патерн «Стратегія» є одним із фундаментальних поведінкових шаблонів. Його основна ідея полягає у виведенні алгоритму з класу та інкапсуляції цього алгоритму у вигляді окремого об’єкта. Тобто, замість того, щоб мати жорстко закодовану поведінку всередині класу, ми делегуємо її об’єкту, що реалізує певну стратегію.
     Таким чином, контекст (тобто клас, який виконує дію) не залежить від конкретної реалізації алгоритму, а лише від інтерфейсу стратегії. Це дає змогу легко змінювати поведінку класу без зміни його коду, що відповідає принципу відкритості/закритості із набору принципів SOLID.
     У розробці програмного забезпечення досить часто зустрічаються ситуації, коли один і той самий клас повинен підтримувати декілька варіантів поведінки, які змінюються залежно від контексту. Типовий приклад — сортування даних, форматування тексту, обрахунок знижок, вибір формату звіту тощо.
     У таких випадках початково застосовуються умовні оператори if-else або switch, які в міру ускладнення логіки призводять до зростання розмірів методу або класу, порушення принципу єдиної відповідальності та складності тестування та розширення функціоналу.
     Патерн «Стратегія» дозволяє винести кожен із можливих варіантів поведінки в окремий клас, забезпечивши чітку модульну структуру та високу гнучкість у застосуванні.
     Для реалізації даного шаблону створюється інтерфейс, який оголошує метод, що реалізує алгоритм. Далі створюються класи, які реалізують цей інтерфейс і містять конкретні варіанти поведінки. Контекст у свою чергу зберігає посилання на об’єкт стратегії та делегує йому відповідні дії.
     Це дозволяє відокремити частини системи, які змінюються, від тих, що залишаються незмінними, і дає змогу динамічно змінювати логіку під час виконання програми.
     З огляду на це, патерн доцільно застосовувати в тих випадках, коли необхідно гнучко змінювати поведінку об’єкта, коли існує кілька варіантів одного й того ж алгоритму, або коли умовна логіка в коді стає надмірно громіздкою та складною для підтримки.
     У межах роботи було реалізовано три практичних приклади використання патерну «Стратегія» у різних контекстах. Приклади коду наведено у додатку В.
     У першому прикладі було реалізовано інтерфейс DiscountStrategy із кількома реалізаціями: відсоткова знижка, фіксована знижка, знижка залежно від суми. Клас ShoppingCart динамічно використовує одну зі стратегій. Кошик в даному прикладі не знає, як саме обчислюється знижка — він делегує це зовнішньому об’єкту.
     У другому прикладі було описано інтерфейс SortStrategy, який реалізує класи з алгоритмами сортування: за зростанням, за спаданням. Клас Sorter може перемикатися між стратегіями в реальному часі. Додаючи новий метод сортування, не потрібно змінювати основний клас, що виконує сортування.
     У третьому прикладі було реалізовано інтерфейс ReportStrategy для створення звітів у форматах CSV, JSON тощо. Клас ReportGenerator взаємодіє з конкретною стратегією, обрану під час виконання. Використання патерну “Стратегія” дає змогу легко масштабувати систему — додати, наприклад, PDF або HTML, не змінюючи існуючі класи.
     Після реалізації прикладів було здійснено їх аналіз, який показав, що патерн «Стратегія» дійсно сприяє зниженню складності коду, забезпечує його гнучкість і масштабованість, а також дозволяє окремо тестувати кожен варіант поведінки. 
     При цьому слід враховувати, що застосування даного патерну може призводити до збільшення кількості класів у проєкті, що ускладнює загальну структуру. Також необхідно подбати про правильну конфігурацію та ініціалізацію стратегій, оскільки помилки на цьому етапі можуть ускладнити виконання програми. Окрім того, надмірне використання шаблону без чіткого обґрунтування доцільності може спричинити зниження зрозумілості коду.
     Таким чином, патерн «Стратегія» є універсальним інструментом, який варто застосовувати в проєктах, де передбачається змінна поведінка та розширення системи без порушення її архітектурної цілісності.
     
     


ВИСНОВКИ

     У ході виконання практичного завдання було детально досліджено патерн проектування «Стратегія», було визначено та проаналізовано його призначення, структурні особливості, варіанти застосування, переваги та недоліки. Було створено та проаналізовано приклади на TypeScript, які демонструють застосування цього патерну проектування.



ДОДАТОК А
Посилання на відеозапис доповіді та текст хронологічного опису доповіді

     Відеозапис доповіді на YouTube: https://youtu.be/dESxb45-fMo
     
     Хронологічний опис доповіді:
00:00 – Привітання. Коротке представлення доповідача та теми доповіді.
00:15 – Зміст. Огляд структури доповіді: що саме буде розглянуто.
00:35 – Вступ. Пояснення загальної проблеми зміни поведінки об'єктів.
01:16 – Проблематика, яку вирішує патерн Стратегія. Недоліки умовних операторів, порушення принципів ООП, труднощі з підтримкою.
02:05 – Визначення патерну Стратегія. Що таке стратегія, її суть і принцип делегування поведінки.
02:43 – Основні риси патерну Стратегія. Інкапсуляція алгоритму, динамічна заміна, дотримання SOLID-принципів.
03:06 – Випадки застосування патерну Стратегія. Коли стратегія особливо корисна — змінна логіка, тестування, уникнення if-else.
03:31 – Практичний приклад №1. Реалізація системи знижок через різні стратегії обчислення ціни.
04:35 – Практичний приклад №2. Приклад сортування з можливістю зміни алгоритму без зміни основного класу.
05:18 – Практичний приклад №3. Генерація звітів у різних форматах завдяки незалежним стратегіям.
06:00 – Переваги патерну Стратегія. Гнучкість, розширюваність, тестованість, відповідність SOLID.
06:38 – Недоліки патерну Стратегія. Зростання кількості класів, складність конфігурації, ризик надмірної абстракції.
07:08 – Випадки небажаного використання. Простий або незмінний алгоритм, критичність продуктивності.
07:35 – Висновки. Підсумок ефективності патерну у використованні.

ДОДАТОК Б
Слайди презентації доповіді

 
Рисунок Б.1 – Титульний слайд

 
Рисунок Б.2 – Зміст презентації

 
Рисунок Б.3 – Вступ

 
Рисунок Б.4 – Проблематика, яку вирішує патерн Стратегія

 
Рисунок Б.5 – Визначення патерну Стратегія

 
Рисунок Б.6 – Основні риси патерну Стратегія

 
Рисунок Б.7 – Випадки застосування патерну Стратегія

 
Рисунок Б.8 – Практичний приклад №1

 
Рисунок Б.9 – Практичний приклад №2

 
Рисунок Б.10 – Практичний приклад №3

 
Рисунок Б.11 – Переваги патерну Стратегія

 
Рисунок Б.12 – Недоліки патерну Стратегія


Рисунок Б.13 – Випадки небажаного використання патерну Стратегія
 
Рисунок Б.14 – Висновки


ДОДАТОК В
Приклади програмного коду

     Практичний приклад №1 «Стратегія вибору знижки»

1  interface DiscountStrategy {
2    calculate(price: number): number;
3  }
4  
5  class NoDiscount implements DiscountStrategy {
6    calculate(price: number): number {
7      return price;
8    }
9  }
10 
11 class BlackFridayDiscount implements DiscountStrategy {
12   calculate(price: number): number {
13     return price * 0.7;
14   }
15 }
16 
17 class NewCustomerDiscount implements DiscountStrategy {
18   calculate(price: number): number {
19     return price * 0.9;
20   }
21 }
22 
23 class ShoppingCart {
24   constructor(private strategy: DiscountStrategy) {}
25 
26   setStrategy(strategy: DiscountStrategy) {
27     this.strategy = strategy;
28   }
29 
30   checkout(price: number): number {
31     return this.strategy.calculate(price);
32   }
33 }
34 
35 const cart = new ShoppingCart(new NoDiscount());
36 console.log(cart.checkout(100));
37 
38 cart.setStrategy(new BlackFridayDiscount());
39 console.log(cart.checkout(100));

     Практичний приклад №2 «Стратегія вибору сортування»

1  interface SortStrategy {
2      sort(data: number[]): number[];
3  }
4  
5  class BubbleSort implements SortStrategy {
6      sort(data: number[]): number[] {
7          console.log('Сортування бульбашкою');
8          return [...data].sort();
9      }
10 }
11 
12 class QuickSort implements SortStrategy {
13     sort(data: number[]): number[] {
14         console.log('Швидке сортування');
15         return [...data].sort();
16     }
17 }
18 
19 class Sorter {
20     constructor(private strategy: SortStrategy) {}
21 
22     setStrategy(strategy: SortStrategy) {
23         this.strategy = strategy;
24     }
25 
26     sort(data: number[]): number[] {
27         return this.strategy.sort(data);
28     }
29 }
30 
31 const sorter = new Sorter(new BubbleSort());
32 console.log(sorter.sort([5, 3, 1]));
33 
34 sorter.setStrategy(new QuickSort());
35 console.log(sorter.sort([5, 3, 1]));

     Практичний приклад №3 «Стратегія вибору формату звіту»

1  interface ReportStrategy {
2      generate(data: any): string;
3  }
4  
5  class JSONReport implements ReportStrategy {
6      generate(data: any): string {
7          return JSON.stringify(data, null, 2);
8      }
9  }
10 
11 class CSVReport implements ReportStrategy {
12     generate(data: any): string {
13         return Object.keys(data).join(",") + "\n" + Object.values(data).join(",");
14     }
15 }
16 
17 class ReportGenerator {
18     constructor(private strategy: ReportStrategy) {}
19 
20     setStrategy(strategy: ReportStrategy) {
21         this.strategy = strategy;
22     }
23 
24     export(data: any): string {
25         return this.strategy.generate(data);
26     }
27 }
28 
29 const report = new ReportGenerator(new JSONReport());
30 console.log(report.export({ name: "Ivan", age: 30 }));
31 
32 report.setStrategy(new CSVReport());
33 console.log(report.export({ name: "Ivan", age: 30 }));
